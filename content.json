[{"title":"UavContrallerDesign_1.1","date":"2020-02-28T14:18:41.000Z","path":"2020/02/28/UavContrallerDesign-1/","text":"无人机飞行控制技术坐标变换（线性空间内的基变换）与线性变换 Unfortunately,no one can be told what the Matrix is. You have to see it for yourself. ​ —— Morpheus 变换&emsp; Transformations ： Transformation is essentially a fancy word for “function”, it’s something that takes in inputs and spits out an output for each one. Specifically, in the context of liner algebra, we like to think about transformations that take in some vector and spit out another vector. The word “transformation” suggests that using movement to understand “function of vectors”. If the transformation takes some input vector to some output vector, we image that input vector moving over the output vector, and all vector in this dimensions do the same things. 下图，是对二维空间进行的一种简单的线性变换: 假设在原来的二维空间中存在等距、正交的网格线，其经过线性变换后，会转变为图像中交错的斜线。 线性变换&emsp;Liner Transformations： 是一种最为简单的变换。与之相对，在复平面上的$f(z)= \\frac{z^2}{2}$变换，会使得图像的网格线扭曲变形，也就不在是“线性”的变化了。我们认为线性变换有以下条件： All lines must remain lines without getting curved. The origin must remain fixed in place，if it did, it’ll be an Affine Transformation. 由此可知，线性变化是保持网格线平行且等距的变换，同时原点必须保持固定。一般线性变化表现为两个动作：旋转与错切，而具体表达这种转换的“函数”，就是矩阵。 假设平面中存在一组标准正交基，处于一组标准的正交系上，向量$\\vec a$ 为$(x,y)$。之后基底经过了一次线性变化。此时，变化后的基底在原来的坐标系上表示为$(a,b)$、$(c,d)$ ,则$\\vec a_1$ 的坐标计算如下：$$\\begin{equation} \\left[ \\begin{array}{c} x_1\\\\ y_1 \\end{array} \\right] =x \\left[ \\begin{array}{c} a\\\\ b \\end{array} \\right]+y \\left[ \\begin{array}{c} c\\\\ d \\end{array} \\right ]\\end{equation}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.1$$这是网格线保持平行且等距分布的重要推论： 如果认为$\\vec a$ 是由原来的正交基经过扩大$x$ 倍和$y$ 倍后相加得到的，他就是由这组标准正交基的一个特定的线性组合，即使空间经过了线性变换，依然不会影响参数 。这就代表这，一个二维的线性变化仅由四个数字来完全确定， 也就是经过线性转换得到的基底的坐标。将他们组合起来，就形成了一个$2*2$的矩阵。$$\\begin{equation} \\left[ \\begin{array}{c} x_1\\\\y_1 \\end{array} \\right] = \\left[ \\begin{array}{c} a&amp;&amp;c\\\\ b&amp;&amp;d \\end{array} \\right ] \\left[ \\begin{array}{c} x\\\\ y \\end{array} \\right]\\end{equation}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.2$$ 可以认为矩阵线性的”变换”了整个空间，也就线性的变换了空间中的所有向量。将$(a,b)$、$(c,d)$看作变换后的基向量，也就很容易理解式1.1中其实依旧是基底扩大$x$ 倍和$y$ 倍后相加的过程，在变化前后，参数保持不变。而矩阵就是“转换”的函数。矩阵先将基底$(1,0)$转换到了$(a,b)$，再将$(0,1)$转换到了$(c,d)$，其余的网格与之保持平行等距，最后达到了变换整个空间的目的。 式-1.2是极为特殊的，原因在于它是由平行且等距得出的结论，是最底层的运算法则，任何其他高纬度的同阶矩阵乘法都可以视为在标准正交基下的n组n阶向量，用n个系数与n个新基底求内积再复合的过程。这样理解可以极大的加快高阶矩阵乘法的运算速度。 12345678&gt;&gt; A=[1,2,3;4,5,6;7,8,9];&gt;&gt; A*Aans = 30 36 42 66 81 96 102 126 150 从这方面看来，矩阵乘法所要求的$j_A=i_B$也是为了要求矩阵乘法运算可以进行，若$i_A&lt;j_A=i_B$则会因错切导致B中的$j$维向量降维到$i$维(因为A只有$i$维)，B中向量的个数不变（$i$不变）。此时无法用上述方法理解，但是计算已经被简化了。若$i_A&gt;j_A=i_B$则A中多余的向量可由其余任意三个线性表示，并不影响计算。 这样就可以得到一个结论：线性变换矩阵A的行影响错切，列影响放缩（把第二个矩阵的列向量上的元素都依次乘A的列向量的原因）。 降维的效果： 由此，就可以更加简单的理解矩阵的乘法。如果说一个矩阵代表了一次function, 那么矩阵左乘就代表了函数复合的过程，$f(g(x))$的映射符号$f$是在左侧嵌套的，这是一种约定的习惯，也就意味着矩阵乘积时我们需要从右往左的进行变换。这也方便了我们规定变换的次序。而我们最终要求出的结果矩阵，其实就是经过两次变换之后的基底，也是我们所要求出的结果和求解的导向。当两个$n$阶矩阵相乘时，右侧矩阵中的列向量代表了当前空间中的基底$\\vec i、\\vec j…$，而左侧的矩阵代表了变换，我们需要提出右侧矩阵中的每一列基底向量，与左侧矩阵做乘积（ 式-1.2 ），得出新的基底向量，组合成新的复合矩阵。 侧面的证明了：$AB \\not= BA$ ，这是一个复合（变化）的先后问题,以函数的角度讲，复合的内外颠倒了。 同样侧面的证明了： $A(BC) = (AB)C$ ，从变化的顺序来看，对于整体并没有影响，（AB）C虽然先是B向A变化，但是之后C又向AB变换，变换的次序从整体来看是向左的，就好像三级复合函数一样$f(g(z(x)))$，可以先以$g(z(x))$为自变量复合，得到$q(z(x))$再次复合，得到的结果是一致的。令$C=E$，也会便于理解。理解什么是基，什么是基的变换，变换的顺序，会保证矩阵的顺序不会出错，避免一些低级的问题。 总结：线性空间转换处理的问题是空间中的所有向量经过矩阵线性变化之后，再用标准正交基表示的问题，在线性转化的过程中，向量本身发生了变化。 基变换与线性空间转换相同的是,基变换同样规定变换前后有相同的原点，认为是$0\\vec v$的值。但是基变换研究的向量本身相对于标准正交基$E$看来，并*没有发生改变**。也就是说，基被某个矩阵转换了，如$\\begin{bmatrix}a&amp;c\\\\ b&amp;d\\end{bmatrix}$,但是这个待表示的向量没有变换。此时该向量在这两组基的表示下，参数是不相同的，如果已知一组参数，那么我们应该可以通过矩阵的变换，求出另一组参数。 变换后的基底组成的复合矩阵，可以看作是变换，在变换后的基底看来是$(x,y)$，但在原来的正交基看来是:$$\\left[\\begin{array}{c}m\\\\q\\end{array}\\right]=\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.3$$这是标准正交基来解释这组变换后的基底的结果。如果想要用这组基底来解释标准正交基表示的向量$(m,q)$，那么就变为了$$\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]=\\begin{equation}\\left[\\begin{array}{c}a&amp;c\\\\b&amp;d\\end{array}\\right]^{-1}\\left[\\begin{array}{c}m\\\\q\\end{array}\\right]\\end{equation}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.4$$ 这样就解决如何在坐标系之间对单个向量的描述进行相互转换。但是如果要对这个向量$\\left[\\begin{array}{c}m\\\\q\\end{array}\\right]$进行矩阵$M$的线性变换，用已经被变化了的基$\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}$描述该向量的方法即$\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]$表示，该如何表示呢？ An express like A^-1MA suggests a mathematical sort of empathy 经过$M$变化,由式-1.3可知：$$Z=M\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.5$$这实际上是$M\\left[\\begin{array}{c}m\\\\q\\end{array}\\right]$的结果，在由式-1.4转化到$\\begin{bmatrix}a&amp;c\\\\ b&amp;d\\end{bmatrix}$这组基底，则为:$$Z=\\begin{equation}\\left[\\begin{array}{c}a&amp;c\\\\b&amp;d\\end{array}\\right]^{-1}\\end{equation}M\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.6$$这样就表示了在基底$\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}$看来$\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]$的$M$变换，其变换矩阵为：$$\\begin{equation}\\left[\\begin{array}{c}a&amp;c\\\\b&amp;d\\end{array}\\right]^{-1}\\end{equation}M\\begin{bmatrix}a&amp;c\\\\b&amp;d\\end{bmatrix}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad-1.7$$这样只要知道在标准正交基下的转换矩阵$M$就可以用基底$\\begin{bmatrix}a&amp;c\\\\ b&amp;d\\end{bmatrix}$表示在平面中的任意线性变换。 总结：基变换描述了向量恒定，基经过线性变换后表示该向量及控制该向量的办法。 坐标变化坐标变化是三维基变换的特殊形式，$i、j、k$轴为标准正交系，且在变换过程中只发生了旋转。","link":"","tags":[{"name":"UavContrallerDesign","slug":"UavContrallerDesign","permalink":"tags/UavContrallerDesign/"},{"name":"Matlab","slug":"Matlab","permalink":"tags/Matlab/"},{"name":"liner algebra","slug":"liner-algebra","permalink":"tags/liner-algebra/"},{"name":"考研","slug":"考研","permalink":"tags/考研/"}]},{"title":"建站记录","date":"2020-02-28T10:43:29.000Z","path":"2020/02/28/hexocreatconig/","text":"建站记录&emsp;&emsp;时隔一年又搭了一次博客，上一次使用hugo是一次完全失败且糟糕的体验，不推荐使用海外的云服务器提供商搭建博客，部署到Github还是相对稳定靠谱的。搭这个博客主要是为了记录自己认为学习的困难点，其次也是为了记录自己考研的一些经历，日后回看，也有感触。 Hexo概述&emsp;&emsp;Hexo是一个快速、简洁且高效的博客框架，它能够将Markdown格式的文档渲染成漂亮的网页，这样我们就可以在很短的时间内迅速的创建出网站的静态内容。要想使用Hexo来搭建自己的博客，官方文档是入手hexo最好的办法,下面我只做一个简要的使用说明。 说明：Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，同时也对图片、图表、数学公式提供了支持，可以用来书写电子书、软件文档等，同时也可以非常方便的转换为HTML页面或者是PDF文档。 &emsp;&emsp;要使用Hexo，首先得确保计算机上已经安装了node.js环境和git环境，前者是一个能够在服务器端运行JavaScript代码的环境，后者是版本控制工具。安装node.js主要是为了使用它的包管理工具npm，所以不需要先系统的学习node.js的知识；而安装git是为了利用版本控制系统克隆代码已经将博客项目托管到三方平台，最好的资料是官方网站上的Git Pro和《Git权威指南》。可以直接从官网安装，也可以使用类似chocolate、scoop、homebrew等包管理工具安装。安装完成后，我们可以通过下面的命令来确认node.js环境以及它的包管理工具是否安装成功。 12node --versionnpm --version 可以通过下面的命令来检查是否安装了git环境。 1git --version 我们可以使用npm来安装Hexo，npm是node.js的包管理工具，跟Python的pip工具作用一样，可以用它来安装依赖库和三方工具。在第一次使用npm的时候，我们可以先将npm的下载源更换为国内的淘宝镜像，这样下载的速度会有非常显著的提升。 1npm config set registry https://registry.npm.taobao.org 接下来我们就通过npm来安装Hexo，命令如下所示。 1npm install -g hexo-cli 安装成功后，就可以使用Hexo来创建属于自己的博客啦。 搭建博客 说明：以下内容基本上来自于Hexo的官方文档，推荐大家阅读官方文档。 我们先通过下面的命令来创建一个专门保存博客项目的文件夹，该命令会从github上克隆博客项目和默认的主题。 1hexo init blog 接下来我们进入这个文件夹并查看目录结构。 12cd blog ls -lR 12345678total 232-rw-r--r-- 1 Hao staff 1768 8 8 01:15 _config.ymldrwxr-xr-x 274 Hao staff 8768 8 8 01:19 node_modules-rw-r--r-- 1 Hao staff 109972 8 8 01:19 package-lock.json-rw-r--r-- 1 Hao staff 443 8 8 01:15 package.jsondrwxr-xr-x 5 Hao staff 160 8 8 01:15 scaffoldsdrwxr-xr-x 3 Hao staff 96 8 8 01:15 sourcedrwxr-xr-x 3 Hao staff 96 8 8 01:15 themes 说明：Windows环境命令行提示符中可以使用dir命令查看目录结构。需要说明的是：_config.yml是博客项目的配置文件；package.json是项目的依赖项文件；scaffolds保存了Markdown文件的模板，也就是向新添加的Markdown文件中默认填充的内容；source目录下有一个名为_post的目录，我们稍后可以将编写好的Markdown文件放到该目录，这样就可以利用Hexo将Markdown文件处理成博客的静态页面，生成的静态页面将置于public目录下；themes文件夹保存了博客使用的主题。 然后我们通过下面的命令来安装项目所需的依赖项（package.json文件指明了这些依赖项）。 1npm install 做完上述的操作以后，我们已经可以直接通过下面的命令来生成博客。 1hexo generate # 生成静态文件 该命令也可以缩写为： 1hexo g 之前我们在安装依赖项的时候包括了一个名为hexo-server的依赖项，该依赖项可以帮助我们启动一个基于node.js的服务器来运行我们的博客项目，使用下面的命令即可启动服务器。 1hexo server 该命令也可以缩写为： 1hexo s 12INFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 从运行命令的提示信息可以看到，服务器已经运转起并使用了4000端口，可以通过Ctrl+C来终止服务器的运行。如果要修改服务器使用的端口，可以在启动服务器的时候加上-p参数；如果希望服务器启动后，自动打开默认的浏览器访问服务器，可以使用-o参数，如下所示。 1hexo s -p 8000 -o 至此，我们已经可以看到Hexo在没有配置也没有加入自己的Markdown文件下生成的首页，如下图所示。 接下来我们修改博客的配置文件。 1vim _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: subtitle: description:keywords:author: language: zhtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: //cherium.funroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 下面是YAML文件中相关选项的说明。 参数 描述 title 网站的标题 subtitle 网站的副标题 description 网站的描述 keywords 网站的关键词，可以用逗号分隔多个关键词 author 自己的名字 language 网站使用的语言 timezone 网站使用时区，默认使用电脑上设置的时区 url 网址 root 网站根目录 source_dir 资源文件夹，这个文件夹用来存放内容，默认source目录 public_dir 公共文件夹，这个文件夹用于存放生成的站点文件，默认public目录 tag_dir 标签文件夹，默认tags目录 archive_dir 归档文件夹，默认archives目录 category_dir 分类文件夹，默认categories目录 auto_spacing 在中文和英文之间加入空格，默认false titlecase 把标题转换为首字母大写，默认false external_link 在新标签中打开链接，默认true relative_link 把链接改为与根目录的相对位址，默认false default_category 默认分类 date_format 日期格式，默认YYYY-MM-DD time_format 时间格式，默认HH:mm:ss per_page 每页显示的文章数量 ，默认值10，0表示不使用分页 pagination_dir 分页目录，默认为page目录 theme 当前主题名称 deploy 部署部分的设置 我们将编写好的Markdown文件可以拷贝到source/_posts目录，我们可以在每个Markdown文件的上方添加Front-matter来对文件的布局、标题、分类、标签、发布日期等信息加以说明。所谓Front-matter，就是每个Markdown文件最上方以---分隔的区域，可以在Front-matter中设置以下内容。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 例如： 1234567891011121314151617---title: Python编程惯例category: Python基础date: 2019-8-1tags:- python---## Python惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。1. 让代码既可以被导入又可以被执行。 if __name__ == '__main__':2. 用下面的方式判断逻辑“真”或“假”。 if x: if not x: 在完成上述工作后，我们可以通过下面的命令先清理之前生成的内容。 1hexo clean 新建标签或blog 12hexo n page \"essays\" # 新建essays标签，生成 source\\essays\\index.mdhexo n \"daily\" # 新建 blog，生成 source\\_post\\daily.md 接下来我们就可以用之前讲过的命令重新生成并运行博客项目。 12hexo g # == hexo generatehexo server -p 8000 -o # == hexo s 将博客托管到GitHub我们可以利用GitHub网站提供的Pages服务来托管我们的博客。在GitHub Pages的首页上就有一个教程指导我们如何托管自己的网站，当然第一步得在GitHub上注册一个属于自己的账号，登录成功之后才能进行后续的操作。 根据自己的用户名创建一个仓库，仓库一定要取名为“用户名.github.io”。例如：我在GitHub上的用户名是luseanevens，那么我的托管博客项目的仓库一定要命名为luseanevens.github.io。 修改博客项目的配置文件_config.yml，配置使用GitHub来部署该博客项目。 1vim _config.yml 1234567# 省略上面的内容# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/luseanevens/luseanevens.github.io branch: master 上面的配置中，type指定了使用git进行项目部署，repo指定了部署项目的git仓库的URL，我们这里使用的是HTTPS的地址，如果之前配置过密钥对也可以使用SSH的地址，branch指定了将代码同步到仓库中的哪一个分支，通常master分支就是发布项目最终工作成果的分支，也称为项目的主分支。 安装名为hexo-deployer-git的部署器插件，通过该插件就能实现一键部署。 1npm install hexo-deployer-git --save 可以使用下面的命令来实现一键部署到GitHub。 1hexo deploy -g 或者 1hexo generate -d 接下来在浏览器中输入luseanevens.github.io就能够看到自己的博客，现在全世界的人都可以通过这个URL来访问你的博客。大家是否注意到，访问你博客的这个URL就是刚才我们给仓库起的名字，因为你在GitHub上注册的用户名是独一无二的，所以这个域名也是全世界独一无二的。 将博客绑定到自己的域名虽然我们已经通过GitHub提供的域名访问到了自己的博客，但是如果我们不愿意“寄人篱下”，我们在利用GitHub Pages提供的托管服务同时，也可以将博客绑定到自己专属的域名。如果暂时还没有购买域名，我们可以在提供域名购买服务的网站（如：万网、GoDaddy）上进行购买。 说明：目前国内对域名的管理日趋严格，在购买域名时需要填写一大堆的个人信息，进行实名认证后才能获得域名，这一点相信大家能够理解。 比如说，我现在已经购买了一个名为“cherium.fun”的域名，如何让它跟“luseanevens.github.io”这个域名做一个绑定呢，我们可以利用阿里云控制台、DNSPod、cloudflare来做一个域名解析服务。在域名解析平台登录成功后，可以添加或选择自己的域名来配置域名解析。点击“添加记录”按钮，创建一个类型为CNAME的域名解析，CNAME类型的解析代表将一个域名解析到另一个域名，如下图所示。 完成这一步后，还不能马上通过自己的域名访问到博客项目，最后需要在博客项目的source目录下添加一个名为CNAME的文件（请注意这个文件的名字是全大写字母的）。 1vim CNAME 编辑该文件的内容，如下所示。 1cherium.fun 在配置DNS解析时，A记录可以不配置，由于Github的IP也时常变动，使用IP配置并不方便，使用CNAME相当于进行了一次域名转接。配置完成之后并不会立即生效，一般通知邮件送到之后就完成了。 个性化基本设置实现头像旋转加入不蒜子统计加入输入特效加入discuz讨论 （已停用）加入网易云插件 （手机端停用）加入点击桃心效果与飘雪效果(手机端有bug)加入 live2d 看板猫 （移动端停用）跳过hexo渲染（跳过*.md渲染会导致公式无法显示）踩到的坑 资源根目录下不能为空，如果删去博客初始化时生成的hello world.md会出现can not get \\,在网页端就是404 Not Found 在npm下载的hexo是博客的管理工具，之后通过blog init可以在任意目录下生成blog，其配置文件在主题内和主题外，主题应该用npm管理而不是git npm作为比较成熟的包管理工具，是大势所趋，比git会更稳定和方便 构建工作交给主题更合适,应当在主题内部的config文件中配置更多的个性化信息 Hexo本身的构建虽然做了很多工作，但是无法适应所有开发者的要求，比如需要用ES6开发，压缩合并js 仓库提交后因先刷新仓库，再进入个人主页 新建标签需要保证配置文件中标签名与标签文件名，命令行新建标签名三者统一 使用文章截断 &lt;!--more--&gt; 公式显示为源代码，是由于未开启hexo的公式渲染功能；公式显示出错，是由于跳过了hexo对*.md的渲染 hexo 支持的 markdown 并不支持 Github Flavored Markdown中的一些补充语法 ==text==，可以使用使用&lt;font color=&gt;&lt;/font&gt;来加亮字体 矩阵换行需要用 \\\\\\\\ 待添的坑 邮箱并未配置有效链接 yilia暂时未解决标签归档、分类的问题，个人认为分类与标签两个功能重复性太大，我很少用到多级分类，实现在archive`搜索栏按照标签检索，对我而言已经足够，issue#835给出了问题解答，尝试之后并不能满意 站内视频、音频播放器 相册功能 tags重定位问题 编译文档时JS与HTML混乱 站内图床","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"tags/hexo/"},{"name":"日记","slug":"日记","permalink":"tags/日记/"}]},{"title":"anaconda Install and Setting","date":"2020-02-27T19:53:10.407Z","path":"2020/02/28/anacondaInstallSetting/","text":"anaconda 安装配置过程原理&emsp;&emsp;不同版本的库需要不同的编译器版本，anaconda可以通过conda创建不同的环境，每个环境都有不同的python版本，可以在激活环境后安装对应的库，从而形成多个封装好的并对应不同应用需求的环境。其关系如下图所示： 在conda activate env后，选取的环境被抽取出来作为当下的环境变量。 anconda自带一个版本的编译器作为自己运行环境的编译器，在安装中可以讲此编译器作为自己的环境变量，在此之前卸载已安装的Python发行版。 在新的机器上，安装是推荐配置好Python和conda的环境变量。（打两个勾 ） Opencv在3.4.2版本后有些算法因被申请专利而无法使用，配置环境使用Opencv ver 3.4.1.15 + Python ver 3.6.3。 12345678conda --versionconda info --env #列出所有环境conda create -n py3.6cv3.4.1 python==3.6.3conda activate py3.6cv3.4.1pip install opencv-python==3.4.1.15pip install opencv-contribe-python==3.4.1.15 #这个包拓展了一些当前opencv没有的算法conda deactivateconda remove --name py3.6cv3.4.1--all 在网站上寻找一些版本较老的包 [Unofficial Windows Binaries for Python Extension Packages](Unofficial Windows Binaries for Python Extension Packages) pypi-tuna 下载到本地后pip install %dirction%","link":"","tags":[{"name":"python","slug":"python","permalink":"tags/python/"},{"name":"DIP","slug":"DIP","permalink":"tags/DIP/"}]}]